// Amazon FPGA Hardware Development Kit
//
// Copyright 2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.
//
// Licensed under the Amazon Software License (the "License"). You may not use
// this file except in compliance with the License. A copy of the License is
// located at
//
//    http://aws.amazon.com/asl/
//
// or in the "license" file accompanying this file. This file is distributed on
// an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express or
// implied. See the License for the specific language governing permissions and
// limitations under the License.

`define SPATIAL_SCALAR_WIDTH 64

module spatial_top (
    input aclk,
    input aresetn,
    axi_bus_t.master ddr4_s_axi_0,
    axi_bus_t.master ddr4_s_axi_1,
    axi_bus_t.master ddr4_s_axi_2,
    axi_bus_t.master ddr4_s_axi_3,

    axi_bus_t.slave host_dma_intf,
    axi_bus_t.slave ul_reg_intf
);

// /*
`ifndef VCS
    initial begin
        $dumpfile("Top.vcd");
        $dumpvars(0, Top_inst);
        $dumpvars(0, miu_inst);
        $dumpvars(1, spatial_top);
        // $dumpvars;
    end
`endif
// */


//----------------------------
// Internal signals
//----------------------------

axi_bus_t Top_mag_bus[3:0]();

logic clk;
(* dont_touch = "true" *) logic pipe_rst_n;
logic pre_sync_rst_n;
(* dont_touch = "true" *) logic sync_rst_n;
logic sh_cl_flr_assert_q;
logic dma_pcis_slv_sync_rst_n; 

// Performance counters
// TODO: Can do this with less area (have 1 counter and print when state changes)
logic [31:0] performance_counter;
logic [31:0] performance_counter_0;
logic [31:0] performance_counter_1;
logic [31:0] performance_counter_2;

//----------------------------
// End Internal signals
//----------------------------

assign clk = aclk;

//reset synchronizer
lib_pipe #(.WIDTH(1), .STAGES(4)) PIPE_RST_N (.clk(clk), .rst_n(1'b1), .in_bus(aresetn), .out_bus(pipe_rst_n));

always_ff @(negedge pipe_rst_n or posedge clk)
   if (!pipe_rst_n)
   begin
      pre_sync_rst_n <= 0;
      sync_rst_n <= 0;
   end
   else
   begin
      pre_sync_rst_n <= 1;
      sync_rst_n <= pre_sync_rst_n;
   end


///////////////////////////////////////////////////////////////////////
///////////////// Samba Top ///////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
logic samba_top_resetn;
logic samba_top_resetn_q; // Samba Top reset signal
logic [`SPATIAL_SCALAR_WIDTH-1:0] SCALAR_argIn__{{{SPATIAL_INSERT_input_argnum}}};
logic [`SPATIAL_SCALAR_WIDTH-1:0] SCALAR_argOut__{{{SPATIAL_INSERT_output_argnum}}};
logic [31:0] SCALAR_en;    // CMD bit from host
logic [31:0] SCALAR_reset; // CMD bit from host
logic [31:0] SCALAR_done;  // Status bit from host

assign samba_top_resetn = SCALAR_reset[0] | ~sync_rst_n;
lib_pipe #(.WIDTH(1), .STAGES(4)) SAMBA_TOP_RST_N (.clk(clk), .rst_n(1'b1), .in_bus(samba_top_resetn), .out_bus(samba_top_resetn_q));

Top Top_inst (
  .clock(clk),
  .reset(samba_top_resetn_q),
  .io_enable(SCALAR_en),
  .io_done(SCALAR_done),

  // Scalars
  .io_scalarIns_{{{SPATIAL_INSERT_input_argnum}}}(SCALAR_argIn__{{{SPATIAL_INSERT_input_argnum}}}),
  .io_scalarOuts_{{{SPATIAL_INSERT_output_argnum}}}(SCALAR_argOut__{{{SPATIAL_INSERT_output_argnum}}}),

  // AXI-4 for DRAM channel A
  .io_M_AXI_0_AWID    (Top_mag_bus[0].awid),    // output [15:0]
  .io_M_AXI_0_AWADDR  (Top_mag_bus[0].awaddr),  // output [31:0]
  .io_M_AXI_0_AWLEN   (Top_mag_bus[0].awlen),   // output [7:0]
  .io_M_AXI_0_AWSIZE  (Top_mag_bus[0].awsize),  // output [2:0]
  .io_M_AXI_0_AWVALID (Top_mag_bus[0].awvalid), // output
  .io_M_AXI_0_AWREADY (Top_mag_bus[0].awready), // input
  .io_M_AXI_0_ARID    (Top_mag_bus[0].arid),    // output [15:0]
  .io_M_AXI_0_ARADDR  (Top_mag_bus[0].araddr),  // output [31:0]
  .io_M_AXI_0_ARLEN   (Top_mag_bus[0].arlen),   // output [7:0]
  .io_M_AXI_0_ARSIZE  (Top_mag_bus[0].arsize),  // output [2:0]
  .io_M_AXI_0_ARVALID (Top_mag_bus[0].arvalid), // output
  .io_M_AXI_0_ARREADY (Top_mag_bus[0].arready), // input
  .io_M_AXI_0_WDATA   (Top_mag_bus[0].wdata),   // output [511:0]
  .io_M_AXI_0_WSTRB   (Top_mag_bus[0].wstrb),   // output [63:0]
  .io_M_AXI_0_WLAST   (Top_mag_bus[0].wlast),   // output
  .io_M_AXI_0_WVALID  (Top_mag_bus[0].wvalid),  // output
  .io_M_AXI_0_WREADY  (Top_mag_bus[0].wready),  // input
  .io_M_AXI_0_RID     (Top_mag_bus[0].rid),     // input  [15:0]
  .io_M_AXI_0_RDATA   (Top_mag_bus[0].rdata),   // input  [511:0]
  .io_M_AXI_0_RRESP   (Top_mag_bus[0].rresp),   // input  [1:0]
  .io_M_AXI_0_RLAST   (Top_mag_bus[0].rlast),   // input
  .io_M_AXI_0_RVALID  (Top_mag_bus[0].rvalid),  // input
  .io_M_AXI_0_RREADY  (Top_mag_bus[0].rready),  // output
  .io_M_AXI_0_BID     (Top_mag_bus[0].bid),     // input  [15:0]
  .io_M_AXI_0_BRESP   (Top_mag_bus[0].bresp),   // input  [1:0]
  .io_M_AXI_0_BVALID  (Top_mag_bus[0].bvalid),  // input
  .io_M_AXI_0_BREADY  (Top_mag_bus[0].bready),  // output

  // AXI-4 for DRAM channel B
  .io_M_AXI_1_AWID    (Top_mag_bus[1].awid),    // output [15:0]
  .io_M_AXI_1_AWADDR  (Top_mag_bus[1].awaddr),  // output [31:0]
  .io_M_AXI_1_AWLEN   (Top_mag_bus[1].awlen),   // output [7:0]
  .io_M_AXI_1_AWSIZE  (Top_mag_bus[1].awsize),  // output [2:0]
  .io_M_AXI_1_AWVALID (Top_mag_bus[1].awvalid), // output
  .io_M_AXI_1_AWREADY (Top_mag_bus[1].awready), // input
  .io_M_AXI_1_ARID    (Top_mag_bus[1].arid),    // output [15:0]
  .io_M_AXI_1_ARADDR  (Top_mag_bus[1].araddr),  // output [31:0]
  .io_M_AXI_1_ARLEN   (Top_mag_bus[1].arlen),   // output [7:0]
  .io_M_AXI_1_ARSIZE  (Top_mag_bus[1].arsize),  // output [2:0]
  .io_M_AXI_1_ARVALID (Top_mag_bus[1].arvalid), // output
  .io_M_AXI_1_ARREADY (Top_mag_bus[1].arready), // input
  .io_M_AXI_1_WDATA   (Top_mag_bus[1].wdata),   // output [511:0]
  .io_M_AXI_1_WSTRB   (Top_mag_bus[1].wstrb),   // output [63:0]
  .io_M_AXI_1_WLAST   (Top_mag_bus[1].wlast),   // output
  .io_M_AXI_1_WVALID  (Top_mag_bus[1].wvalid),  // output
  .io_M_AXI_1_WREADY  (Top_mag_bus[1].wready),  // input
  .io_M_AXI_1_RID     (Top_mag_bus[1].rid),     // input  [15:0]
  .io_M_AXI_1_RDATA   (Top_mag_bus[1].rdata),   // input  [511:0]
  .io_M_AXI_1_RRESP   (Top_mag_bus[1].rresp),   // input  [1:0]
  .io_M_AXI_1_RLAST   (Top_mag_bus[1].rlast),   // input
  .io_M_AXI_1_RVALID  (Top_mag_bus[1].rvalid),  // input
  .io_M_AXI_1_RREADY  (Top_mag_bus[1].rready),  // output
  .io_M_AXI_1_BID     (Top_mag_bus[1].bid),     // input  [15:0]
  .io_M_AXI_1_BRESP   (Top_mag_bus[1].bresp),   // input  [1:0]
  .io_M_AXI_1_BVALID  (Top_mag_bus[1].bvalid),  // input
  .io_M_AXI_1_BREADY  (Top_mag_bus[1].bready),  // output
  
  // AXI-4 for DRAM channel C
  .io_M_AXI_2_AWID    (Top_mag_bus[2].awid),    // output [15:0]
  .io_M_AXI_2_AWADDR  (Top_mag_bus[2].awaddr),  // output [31:0]
  .io_M_AXI_2_AWLEN   (Top_mag_bus[2].awlen),   // output [7:0]
  .io_M_AXI_2_AWSIZE  (Top_mag_bus[2].awsize),  // output [2:0]
  .io_M_AXI_2_AWVALID (Top_mag_bus[2].awvalid), // output
  .io_M_AXI_2_AWREADY (Top_mag_bus[2].awready), // input
  .io_M_AXI_2_ARID    (Top_mag_bus[2].arid),    // output [15:0]
  .io_M_AXI_2_ARADDR  (Top_mag_bus[2].araddr),  // output [31:0]
  .io_M_AXI_2_ARLEN   (Top_mag_bus[2].arlen),   // output [7:0]
  .io_M_AXI_2_ARSIZE  (Top_mag_bus[2].arsize),  // output [2:0]
  .io_M_AXI_2_ARVALID (Top_mag_bus[2].arvalid), // output
  .io_M_AXI_2_ARREADY (Top_mag_bus[2].arready), // input
  .io_M_AXI_2_WDATA   (Top_mag_bus[2].wdata),   // output [511:0]
  .io_M_AXI_2_WSTRB   (Top_mag_bus[2].wstrb),   // output [63:0]
  .io_M_AXI_2_WLAST   (Top_mag_bus[2].wlast),   // output
  .io_M_AXI_2_WVALID  (Top_mag_bus[2].wvalid),  // output
  .io_M_AXI_2_WREADY  (Top_mag_bus[2].wready),  // input
  .io_M_AXI_2_RID     (Top_mag_bus[2].rid),     // input  [15:0]
  .io_M_AXI_2_RDATA   (Top_mag_bus[2].rdata),   // input  [511:0]
  .io_M_AXI_2_RRESP   (Top_mag_bus[2].rresp),   // input  [1:0]
  .io_M_AXI_2_RLAST   (Top_mag_bus[2].rlast),   // input
  .io_M_AXI_2_RVALID  (Top_mag_bus[2].rvalid),  // input
  .io_M_AXI_2_RREADY  (Top_mag_bus[2].rready),  // output
  .io_M_AXI_2_BID     (Top_mag_bus[2].bid),     // input  [15:0]
  .io_M_AXI_2_BRESP   (Top_mag_bus[2].bresp),   // input  [1:0]
  .io_M_AXI_2_BVALID  (Top_mag_bus[2].bvalid),  // input
  .io_M_AXI_2_BREADY  (Top_mag_bus[2].bready),  // output
  
  // AXI-4 for DRAM channel D
  .io_M_AXI_3_AWID    (Top_mag_bus[3].awid),    // output [15:0]
  .io_M_AXI_3_AWADDR  (Top_mag_bus[3].awaddr),  // output [31:0]
  .io_M_AXI_3_AWLEN   (Top_mag_bus[3].awlen),   // output [7:0]
  .io_M_AXI_3_AWSIZE  (Top_mag_bus[3].awsize),  // output [2:0]
  .io_M_AXI_3_AWVALID (Top_mag_bus[3].awvalid), // output
  .io_M_AXI_3_AWREADY (Top_mag_bus[3].awready), // input
  .io_M_AXI_3_ARID    (Top_mag_bus[3].arid),    // output [15:0]
  .io_M_AXI_3_ARADDR  (Top_mag_bus[3].araddr),  // output [31:0]
  .io_M_AXI_3_ARLEN   (Top_mag_bus[3].arlen),   // output [7:0]
  .io_M_AXI_3_ARSIZE  (Top_mag_bus[3].arsize),  // output [2:0]
  .io_M_AXI_3_ARVALID (Top_mag_bus[3].arvalid), // output
  .io_M_AXI_3_ARREADY (Top_mag_bus[3].arready), // input
  .io_M_AXI_3_WDATA   (Top_mag_bus[3].wdata),   // output [511:0]
  .io_M_AXI_3_WSTRB   (Top_mag_bus[3].wstrb),   // output [63:0]
  .io_M_AXI_3_WLAST   (Top_mag_bus[3].wlast),   // output
  .io_M_AXI_3_WVALID  (Top_mag_bus[3].wvalid),  // output
  .io_M_AXI_3_WREADY  (Top_mag_bus[3].wready),  // input
  .io_M_AXI_3_RID     (Top_mag_bus[3].rid),     // input  [15:0]
  .io_M_AXI_3_RDATA   (Top_mag_bus[3].rdata),   // input  [511:0]
  .io_M_AXI_3_RRESP   (Top_mag_bus[3].rresp),   // input  [1:0]
  .io_M_AXI_3_RLAST   (Top_mag_bus[3].rlast),   // input
  .io_M_AXI_3_RVALID  (Top_mag_bus[3].rvalid),  // input
  .io_M_AXI_3_RREADY  (Top_mag_bus[3].rready),  // output
  .io_M_AXI_3_BID     (Top_mag_bus[3].bid),     // input  [15:0]
  .io_M_AXI_3_BRESP   (Top_mag_bus[3].bresp),   // input  [1:0]
  .io_M_AXI_3_BVALID  (Top_mag_bus[3].bvalid),  // input
  .io_M_AXI_3_BREADY  (Top_mag_bus[3].bready)   // output
);


///////////////////////////////////////////////////////////////////////
///////////////// MIU module //////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

lib_pipe #(.WIDTH(1), .STAGES(4)) DMA_PCIS_SLV_SLC_RST_N (.clk(clk), .rst_n(1'b1), .in_bus(sync_rst_n), .out_bus(dma_pcis_slv_sync_rst_n));
 
 miu miu_inst (
   .aclk(clk),
   .aresetn(dma_pcis_slv_sync_rst_n),

   .lcl_cl_sh_ddra(ddr4_s_axi_0),
   .lcl_cl_sh_ddrb(ddr4_s_axi_1),
   .lcl_cl_sh_ddrd(ddr4_s_axi_3),
   .cl_sh_ddr_bus(ddr4_s_axi_2),

   .sh_cl_dma_pcis_bus(host_dma_intf),

   .Top_mag_bus(Top_mag_bus)
);


///////////////////////////////////////////////////////////////////////
///////////////// OCL SLAVE module ////////////////////////////////////
///////////////////////////////////////////////////////////////////////

(* dont_touch = "true" *) logic ocl_slv_sync_rst_n;
lib_pipe #(.WIDTH(1), .STAGES(4)) OCL_SLV_SLC_RST_N (.clk(clk), .rst_n(1'b1), .in_bus(sync_rst_n), .out_bus(ocl_slv_sync_rst_n));
cl_ocl_slv CL_OCL_SLV (

   .clk(clk),
   .sync_rst_n(ocl_slv_sync_rst_n),

   .sh_cl_flr_assert_q(sh_cl_flr_assert_q),

   .sh_ocl_bus  (ul_reg_intf),
 
   .SCALAR_argIn__{{{SPATIAL_INSERT_input_argnum}}}(SCALAR_argIn__{{{SPATIAL_INSERT_input_argnum}}}),
   .SCALAR_argOut__{{{SPATIAL_INSERT_output_argnum}}}(SCALAR_argOut__{{{SPATIAL_INSERT_output_argnum}}}),
   .SCALAR_en(SCALAR_en),
   .SCALAR_reset(SCALAR_reset),
   .SCALAR_done(SCALAR_done),
   .performance_counter_1(performance_counter_1)

);

///////////////////////////////////////////////////////////////////////
///////////////// Performacne Measurements/////////////////////////////
///////////////////////////////////////////////////////////////////////

  // State machine to set a bit high during duration of design execution
  logic [2:0] design_state; // S0 = initializing DDR, S1 = running, S2 = done
  always_ff @(posedge clk or negedge sync_rst_n) begin
    if (!sync_rst_n | SCALAR_reset[0])
      design_state <= 0;
    else begin
      if (design_state === 0) begin
        if (SCALAR_en[0]) begin
          design_state <= 1;
        end else begin
          design_state <= 0;
        end
      end else if (design_state === 1) begin
        if (SCALAR_done[0]) begin
          design_state <= 2;
        end else begin
          design_state <= 1;
        end
      end else begin
        design_state <= 2;
      end
    end
  end

  // Perf Counter
  always_ff @(posedge clk or negedge sync_rst_n) begin
    if (!sync_rst_n | SCALAR_reset[0]) begin
      performance_counter <= 0;
      performance_counter_0 <= 0;
      performance_counter_1 <= 0;
      performance_counter_2 <= 0;
    end else begin
      performance_counter <= performance_counter + 1;
      if (design_state === 0) begin
        performance_counter_0 <= performance_counter_0 + 1;
      end else if (design_state === 1) begin
        performance_counter_1 <= performance_counter_1 + 1;
      end else if (design_state === 2) begin
        performance_counter_2 <= performance_counter_2 + 1;
      end
    end
  end

`ifdef SIM
  always_ff @(posedge SCALAR_done[0]) begin
    $display("App done, # cycles total = %d", performance_counter);
    $display("          # cycles init  = %d", performance_counter_0);
    $display("          # cycles run   = %d", performance_counter_1);
    $display("          # cycles done  = %d", performance_counter_2);
  end
`endif

endmodule
